{"data":{"site":{"siteMetadata":{"title":"Sebastian Klingler | UI Engineer","author":"Sebastian Klingler"}},"markdownRemark":{"id":"627f9758-a852-5f24-aa86-962e2c75d08e","html":"<p>I often find myself in situations where I am hesitant to make a change because it’s impossible to tell what will break.</p>\n<p>When a number of things implicitly depend on one another, there is no risk-free change.</p>\n<p>Rich Hickey (the creator of Clojure) gave <a href=\"https://www.infoq.com/presentations/Simple-Made-Easy\">a really great talk</a>. He points out that there are two types of complexity:</p>\n<blockquote>\n<p><em>Inherent complexity</em> is the complexity which is inherent to the business logic. It exists in any domain.</p>\n</blockquote>\n<blockquote>\n<p><em>Incidental complexity</em> is the complexity introduced by design decisions.</p>\n</blockquote>\n<p>It is incidental complexity that we can avoid and should strive to minimize.</p>\n<h2>Shared Mutability</h2>\n<p>In my experience, one of the primary contributors to incidental complexity is shared mutable state. To understand shared mutable state let’s first define mutability:</p>\n<blockquote>\n<p><em>Mutability</em> is the idea that a value can be changed.</p>\n</blockquote>\n<p>In Javascript for example, if we have a variable containing a number we can assign a different number to it. This is mutability.</p>\n<p>If multiple places reference that variable, they will all implicitly depend on any process that changes the value. This is <em>shared mutability</em> - multiple entities referencing a shared bit of state that can be changed.</p>\n<p>When working in an environment with lots of shared mutability, the burden falls on the programmer to map the relationships between different entitites and processes. It is no longer explicit what depends on what, or which order things need to occur.</p>\n<h2>Simplicity</h2>\n<p>Luckily, there are powerful tools available in the Javascript ecosystem that reduce shared mutability and in turn, complexity.</p>\n<p><a href=\"https://facebook.github.io/flux/\">Flux</a> is a convention for structuring state updates popularized by Facebook. It prescribes that the state of an application can only be updated in a single place, making it much easier to reason about a given state.</p>\n<p>Flux is just a design pattern though - popular implementations of Flux include <a href=\"https://redux.js.org/\">Redux</a> and <a href=\"https://vuex.vuejs.org/\">Vuex</a>. Redux is fully immutable, and Vuex is fully mutable, but both follow the principles of Flux and structure state updates. They also prioritize the separation of business logic and view logic.</p>\n<p>Using these libraries is a step in the right direction, but I wanted to take the reduction of shared mutability to it’s logical conclusion.</p>\n<h2>Functional Programming</h2>\n<p>Functional programming, or FP for short, is a programming paradigm that actively avoids shared mutability. It is a very different approach from Object Oriented programming.</p>\n<p>Everything in OO is an object and mutability is widespread. Everything in FP is a function and all values are immutable. FP also prioritizes the use of pure functions:</p>\n<blockquote>\n<p><em>Pure functions</em> always return the same output for a given input and do not have any side effects.</p>\n</blockquote>\n<p>This gives rise to the idea of referential transparency:</p>\n<blockquote>\n<p><em>Referential transparency</em> says a function call could be replaced with it’s output and the program would not be affected in any way.</p>\n</blockquote>\n<p>Pure functions are highly testable because nothing outside of the function needs to be considered. The inputs must simply be matched with the expected outputs.</p>\n<p>Most functional languages also have a strong static type system. Types are checked at compile time, and a whole class of run time bugs are eliminated.</p>\n<p>If every function in a program were pure, there would be no way to tell that the program ever ran because there would be no side-effects. While FP prioritizes purity, it does allow for side effects. However, these side effects are controlled in that they are encoded directly into the type system. So when a function does effect something outside of itself, you can immediately tell by the function signature.</p>\n<p>As a whole, these features lead to programs that are easier to reason about.</p>\n<h2>Purescript</h2>\n<p>You can get most of the benefits of functional programming in modern web applications by using things like Redux, Typescript, and Immutable.js. Augmenting Javascript in such a way does yield some of the benefits of the funcional paradigm. However, Javascript was not designed to be a functional language. The tools we layer on top of it never solve 100% of the problem and are never quite as ergonomic as using something with these ideals baked in.</p>\n<p>I began using <a href=\"http://www.purescript.org/\">Purescript</a> to apply fp techniques to front end applications. Purescript compiles to javascript meaning you get 100% of the cross platform support with 100% of the benefits of a pure functional language.</p>\n<p>There are alternatives to Purescript such as ReasonML, Elm, or even compiling Haskell to Javascript, but I have found Purescript to be easy to work with while still being extremely powerful.</p>\n<h2>Language Features</h2>\n<p>Purescript has some amazing features that make writing business logic very straightforward.</p>\n<h3>Pattern Matching</h3>\n<div class=\"gatsby-highlight\" data-language=\"haskell\">\n      <pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">f</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Boolean</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">f</span> <span class=\"token hvariable\">true</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"It's true\"</span>\n<span class=\"token hvariable\">f</span> <span class=\"token hvariable\">false</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"It's not :(\"</span></code></pre>\n      </div>\n<p>Here we see a function <code class=\"language-text\">f</code> that has the type <code class=\"language-text\">Boolean -&gt; String</code>. This means that it accepts a Boolean argument and returns a String. This first line is the type annotation.</p>\n<p>The two lines below the type annotation are pattern matching cases. When this function is evaluated, purescript will run through these cases top to bottom to find the first pattern which the arguments match. In this case, if <code class=\"language-text\">f</code> is passed true it will return <code class=\"language-text\">It&#39;s true</code>. Otherwise, if <code class=\"language-text\">f</code> is passed false, it will return <code class=\"language-text\">It&#39;s not :(</code>.</p>\n<p>The compiler also ensures that you covere all the possible cases, meaning that you will never forget to handle possible variation of the arguments. This is a very declarative way to write a common piece of logic that would look quite different in javascript. In javascript you would presumably write a conditional to check the value of the argument:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">checkTrue</span><span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token string\">\"It's true\"</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">\"It's not :(\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>Or perhaps a more terse ES6 version with an arrow function:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">checkTrue</span> <span class=\"token operator\">=</span> flag <span class=\"token operator\">=></span> flag <span class=\"token operator\">?</span> <span class=\"token string\">\"It's true\"</span> <span class=\"token punctuation\">:</span> <span class=\"token string\">\"It's not :(\"</span><span class=\"token punctuation\">;</span></code></pre>\n      </div>\n<p>But pattern matching is much more powerful than simple booleans. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\">\n      <pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">sumOfProducts</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Number</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Number</span>\n<span class=\"token hvariable\">sumOfProducts</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token hvariable\">sumOfProducts</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">_</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n<span class=\"token hvariable\">sumOfProducts</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">n</span> <span class=\"token operator\">:</span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">:</span> <span class=\"token hvariable\">ns</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">m</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">sumOfProducts</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">m</span> <span class=\"token operator\">:</span> <span class=\"token hvariable\">ns</span><span class=\"token punctuation\">)</span></code></pre>\n      </div>\n<p>This function taks an array of Numbers and returns a Number by pattern matches the following cases:</p>\n<ol>\n<li>\n<p>An empty array is provided - returns 0</p>\n</li>\n<li>\n<p>An array with only one element is provied - returns 0 (by convention the underscore denotes that the actual value is not going to be used)</p>\n</li>\n<li>\n<p>An array pattern is used to split the array into three pieces:</p>\n<ul>\n<li><code class=\"language-text\">n</code> being the first element</li>\n<li><code class=\"language-text\">m</code> being the second element</li>\n<li><code class=\"language-text\">ns</code> being the array of remaining elements.</li>\n</ul>\n<p>These three pieces are then used to recursively calculate the sum of each pair of products.</p>\n</li>\n</ol>\n<p>Something like this in javascript would be much more verbose and less declarative.</p>\n<h3>Tagged Unions</h3>\n<p>One of my favorite things about Purescript is that there is not concept of null or undefined.</p>\n<p>Who hasn’t run into <code class=\"language-text\">cannot read property x of undefined</code>? In fact, the inventor of the null reference caslled it a billion-dollar mistake.</p>\n<p>Purescript explicitly calls out the possibility of the lack of a value in it’s type system. The way this is done is using something called tagged unions.</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\">\n      <pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">data</span> <span class=\"token constant\">Maybe</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Just</span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">|</span> <span class=\"token constant\">Nothing</span></code></pre>\n      </div>\n<p>Here we see the definition for a tagged union data type that states that <code class=\"language-text\">Maybe</code> has a type parameter <code class=\"language-text\">a</code> and can be constructed using either a <code class=\"language-text\">Just a</code> constuctor or a <code class=\"language-text\">Nothing</code> constructor.</p>\n<p>To see this in action let’s look at a function that sets the default value for a string if it doesn’t exist:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\">\n      <pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">defaultName</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Maybe</span> <span class=\"token constant\">String</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token constant\">String</span>\n<span class=\"token hvariable\">defaultName</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Just</span> <span class=\"token hvariable\">name</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">name</span>\n<span class=\"token hvariable\">defaultName</span> <span class=\"token constant\">Nothing</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"My Default Name\"</span></code></pre>\n      </div>\n<p><code class=\"language-text\">defaultName</code> accepts a <code class=\"language-text\">Maybe String</code> meaning that it can accept either a <code class=\"language-text\">Just String</code> or a <code class=\"language-text\">Nothing</code>. We can then pattern match on these cases to return the appropriate value. And of course, the compiler will complain if you leave out a possible case.</p>\n<p>Encoding the lack of values into the type system like this means that you will never run into a situation in runtime where something is undefined, effectively eliminating a whole class of bugs.</p>\n<h3>Partial Application</h3>\n<p>In Purescript, every function is automatically curried. This means that if a function is invoked with fewer than it’s specified number of arguments, a new function is returned accepting the remaining arguments. This allows you to make a more specific function out of a more general one. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\">\n      <pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">add</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">y</span>\n<span class=\"token hvariable\">add1</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">add</span> <span class=\"token number\">1</span>\n<span class=\"token hvariable\">add1</span> <span class=\"token number\">2</span> <span class=\"token comment\">-- returns 3</span></code></pre>\n      </div>\n<p>I’ve left the type annotation off in this case, but <code class=\"language-text\">add</code> is a function taking two arguments <code class=\"language-text\">x</code> &#x26; <code class=\"language-text\">y</code>. <code class=\"language-text\">add</code> can be specialized by calling it with only one argument. When it’s called with <code class=\"language-text\">1</code> in this case we end up with a new function <code class=\"language-text\">add1</code> that only takes one argument.</p>\n<p>This same things can be achieved in javascript, and arrow functions make this especially nice:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add</span> <span class=\"token operator\">=</span> x <span class=\"token operator\">=></span> y <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> y<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add1</span> <span class=\"token operator\">=</span> x <span class=\"token operator\">=></span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">add1</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// returns 3</span></code></pre>\n      </div>\n<p>But because in Purescript <em>every</em> function behaves like this, it means that even libraries and third party dependencies can be used in the powerful way.</p>\n<h3>Composition</h3>\n<p>Composition is the idea of taking multiple functions and chaining them together or <em>composing</em> them. The output of the first function becomse the input to the second function. In javascript this is done as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add1</span> <span class=\"token operator\">=</span> x <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">mutiply2</span> <span class=\"token operator\">=</span> x <span class=\"token operator\">=></span> x <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">add1Multiply2</span> <span class=\"token operator\">=</span> x <span class=\"token operator\">=></span> <span class=\"token function\">multiply2</span><span class=\"token punctuation\">(</span><span class=\"token function\">add1</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre>\n      </div>\n<p>Here we have two functions that perform calculations and a third function that is the composition of the two. In Purescript, functions can be composed using the composition operator <code class=\"language-text\">&lt;&lt;&lt;</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\">\n      <pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">add1</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n<span class=\"token hvariable\">multiply2</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span>\n<span class=\"token hvariable\">add1Multiply2</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">multiply2</span> <span class=\"token operator\">&lt;&lt;&lt;</span> <span class=\"token hvariable\">add1</span></code></pre>\n      </div>\n<p>It also supports a forward composition operator which makes the whole thing a little more legible to our minds that read things from left to right:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\">\n      <pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">add1</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n<span class=\"token hvariable\">multiply2</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">*</span> <span class=\"token number\">2</span>\n<span class=\"token hvariable\">add1Multiply2</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">add1</span> <span class=\"token operator\">>>></span> <span class=\"token hvariable\">multiply2</span></code></pre>\n      </div>\n<p>Notice that in purescript we can forego manually declaring the argument for <code class=\"language-text\">add1Multiply2</code> and passing it into <code class=\"language-text\">add1</code>. Not having to worry about wiring together the arguments allows us to think about the function at a higher level, as simply the composition of <code class=\"language-text\">add1</code> and <code class=\"language-text\">multiply2</code>.</p>\n<h2>Using Purescript with Vue</h2>\n<p>Ok, so purescript looks pretty cool, how do I go about using it?</p>\n<p>Because purescript is built to interop with javascript, there is a webpack plugin call <a href=\"https://github.com/ethul/purs-loader\">purs-loader</a> that will automatically bundle your purescript code and allow you to import it into your project.</p>\n<p>And because Vue supports custom build configuration in <code class=\"language-text\">vue.config.js</code> using webpack chaining, we don’t have to eject our app like we would in React:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\">\n      <pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token comment\">// vue.config.js</span>\nmodule<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  chainWebpack<span class=\"token punctuation\">:</span> config <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\n    config<span class=\"token punctuation\">.</span>module\n      <span class=\"token punctuation\">.</span><span class=\"token function\">rule</span><span class=\"token punctuation\">(</span><span class=\"token string\">'purescript'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/\\.purs$/</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span><span class=\"token string\">'purs-loader'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>After that bit of configuration, you’ll be able to import Purescript modules just like you would import regular ES Modules:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">import { reducer as counter } from &#39;./Counter/Reducer.purs&#39;\nimport { reducer as board } from &#39;./Board/Reducer.purs&#39;\nimport { initialAction } from &#39;./App/Reducer.purs&#39;</code></pre>\n      </div>\n<p>You can find the source code for an example vue application built with Purescript <a href=\"https://github.com/sliptype/vue-pure\">here</a>.</p>\n<h2>Vuex vs Redux</h2>\n<p>In my first attempt at using Purescript in a Vue application I used Vuex to handle state management. I soon realized that unfortunately, Vuex is not a good candidate for purescript interop because it depends on mutability.</p>\n<p>Purescript has no concept of mutability and using it with Vuex would require mapping immutable state updates to the mutable Vuex state. Although not impossible, it does present a performance concern as well as hindering reducer composition.</p>\n<p>Luckily, Redux is fully immutable and has nice bindings to work with vue. In particular I used <a href=\"https://github.com/titouancreach/vuejs-redux\">vuejs-redux</a>.</p>\n<h2>Canonical Counter Example</h2>\n<p>The Counter vue component is a “dumb” component in that it has no idea how the state is being handled. It merely expects <code class=\"language-text\">props</code>, and <code class=\"language-text\">actions</code>, displays the value of the counter and displays 2 buttons for dispatching <code class=\"language-text\">increment</code> and <code class=\"language-text\">decrement</code> actions:</p>\n<div class=\"gatsby-highlight\" data-language=\"html\">\n      <pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>template</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span>Counter: {{ props.value }}<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">@click</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>actions.increment(1)<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Increment<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">@click</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>actions.decrement(1)<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>Decrement<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>template</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>script</span><span class=\"token punctuation\">></span></span><span class=\"token script language-javascript\">\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  name<span class=\"token punctuation\">:</span> <span class=\"token string\">'Counter'</span><span class=\"token punctuation\">,</span>\n  props<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'actions'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'props'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span>\n</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>script</span><span class=\"token punctuation\">></span></span></code></pre>\n      </div>\n<p>The actions for this component are defined in purescript, using a tagged union. Notice that we don’t have to use a <code class=\"language-text\">type</code> string like we would normally have on a redux action:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\">\n      <pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">module</span> <span class=\"token constant\">State.Counter.Action</span> <span class=\"token keyword\">where</span>\n\n<span class=\"token comment\">-- Action is a tagged union</span>\n<span class=\"token comment\">-- with a constructor for each type of action</span>\n<span class=\"token keyword\">data</span> <span class=\"token constant\">Action</span>\n  <span class=\"token operator\">=</span> <span class=\"token constant\">Increment</span> <span class=\"token constant\">Int</span>\n  <span class=\"token operator\">|</span> <span class=\"token constant\">Decrement</span> <span class=\"token constant\">Int</span></code></pre>\n      </div>\n<p>This is declaring our action as a data type that can either be an <code class=\"language-text\">Increment</code> or a <code class=\"language-text\">Decrement</code> containing an <code class=\"language-text\">Int</code>;</p>\n<p>Then our reducer really let’s purescript shine:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\">\n      <pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token hvariable\">counterReducer</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Action</span> <span class=\"token operator\">-></span> <span class=\"token constant\">State</span> <span class=\"token operator\">-></span> <span class=\"token constant\">State</span>\n<span class=\"token hvariable\">counterReducer</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Increment</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">state</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">state</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">x</span>\n<span class=\"token hvariable\">counterReducer</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Decrement</span> <span class=\"token hvariable\">x</span><span class=\"token punctuation\">)</span> <span class=\"token hvariable\">state</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">state</span> <span class=\"token operator\">-</span> <span class=\"token hvariable\">x</span>\n<span class=\"token hvariable\">counterReducer</span> <span class=\"token hvariable\">_</span> <span class=\"token hvariable\">state</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">state</span></code></pre>\n      </div>\n<p>Here we define our counter reducer as a function taking an <code class=\"language-text\">Action</code>, a <code class=\"language-text\">State</code>, and returning a <code class=\"language-text\">State</code>. Then we can pattern match on the incoming action, pull out the payload, and use it to perform our business logic.\nWe also have a base case at the bottom which handles Actions not matching the ones specified.</p>\n<p>A corresponding reducer in javascript is much more verbose and less declarative:</p>\n<p>TODO: javascript reducer</p>\n<p>Now, to tie the Counter component to it’s reducer we use the <code class=\"language-text\">Provider</code> component provided by <code class=\"language-text\">vuejs-redux</code> and pass it 2 functions:</p>\n<ul>\n<li><code class=\"language-text\">mapStateToProps</code> which takes a State and returns the props to be passed to the component</li>\n<li><code class=\"language-text\">mapDispatchToProps</code> which takes a Dispatch function and returns the props (actions) to be passed to the components</li>\n</ul>\n<p>If you have used Redux before these will be familiar. In this case we defined them in purescript. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"haskell\">\n      <pre class=\"language-haskell\"><code class=\"language-haskell\"><span class=\"token keyword\">type</span> <span class=\"token constant\">CounterProps</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">value</span> <span class=\"token operator\">::</span> <span class=\"token constant\">State</span> <span class=\"token punctuation\">}</span>\n\n<span class=\"token hvariable\">mapStateToProps</span> <span class=\"token operator\">::</span> <span class=\"token hvariable\">forall</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">.</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">counter</span> <span class=\"token operator\">::</span> <span class=\"token constant\">State</span> <span class=\"token operator\">|</span> <span class=\"token hvariable\">a</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">-></span> <span class=\"token constant\">CounterProps</span>\n<span class=\"token hvariable\">mapStateToProps</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">counter</span> <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">value</span><span class=\"token operator\">:</span> <span class=\"token hvariable\">counter</span> <span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>This function accepts any type that has a <code class=\"language-text\">counter</code> field of type <code class=\"language-text\">State</code> and returns a record of type <code class=\"language-text\">CounterProps</code>. Because our state for the counter it just an int this function is very minimal.</p>\n<h2>Conclusion</h2>\n<p>Separating your business logic from your view logic is critical to reducing complexity in modern web apps. Tools like Redux and Vuex reduce complexity further by utilizing functional programming principles. Purescript can be used in conjuction with these tools to make business logic more robust and testable.</p>","frontmatter":{"title":"Functional Front-End with Vue and Purescript","date":null}}},"pageContext":{"jsonName":"functional-front-end-704","internalComponentName":"ComponentFunctionalFrontEnd","path":"/functional-front-end/","component":"/Users/sebastian/workspace/sliptype.github.io/src/templates/blog-post.js","componentChunkName":"component---src-templates-blog-post-js","context":{"slug":"/functional-front-end/","previous":{"fields":{"slug":"/styling-in-cyclejs/"},"frontmatter":{"title":"Styling in Cycle.js"}},"next":null},"updatedAt":1554687996431,"pluginCreator___NODE":"Plugin default-site-plugin","pluginCreatorId":"Plugin default-site-plugin","componentPath":"/Users/sebastian/workspace/sliptype.github.io/src/templates/blog-post.js","slug":"/functional-front-end/","previous":{"fields":{"slug":"/styling-in-cyclejs/"},"frontmatter":{"title":"Styling in Cycle.js"}},"next":null}}