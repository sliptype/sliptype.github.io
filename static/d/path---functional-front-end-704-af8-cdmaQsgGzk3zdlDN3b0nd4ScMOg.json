{"data":{"site":{"siteMetadata":{"title":"Sebastian Klingler | UI Engineer","author":"Sebastian Klingler"}},"markdownRemark":{"id":"627f9758-a852-5f24-aa86-962e2c75d08e","html":"<p>Have you ever found yourself in a situation where you are hesitant to make a change because it is impossible to tell what will break?</p>\n<p>I know I have. I have been burned by unnecessarily complex state, where an arbitrary number of things all depend on one another. It’s one of the initial reasons I went down the rabbit hole of using functional programming to build modern web apps.</p>\n<p>Rich Hickey (the creator of Clojure) has a really great talk in which he points out that there are two types of complexity we deal with when building apps. </p>\n<blockquote>\n<p><em>Inherent Complexity</em> which exists in any domain, is the complexity which is inherent to the business logic.\n<em>Incidental Complexity</em> on the other hand, is the complexity introduces by design decisions. It is incidental complexity that can be avoided and we should strive to minimize.</p>\n</blockquote>\n<p>In my experience, one of the primary contributors to incidental complexity is shared mutable state. To understand shared mutable state let’s first define mutability. Mutability is the idea that a value that is being referenced can be changed. For example in javascript, if we have a variable containing a number we can assign a different number to it. This is mutability. Now, if multiple places in the code reference that variable, they will all be using the new number. This is shared mutability - multiple entities referencing a shared bit of state that can be changed.</p>\n<p>When working in an environment with lots of shared mutability, the burden falls on the programmer to map the relationships between different entitites and processes. It is no longer explicit what depends on what, or which order things need to occur in.</p>\n<h1>Simplicity</h1>\n<p>How do we reduce complexity in our applications? A good starting point is reducing the amount of shared mutability. There are popular tools in the javascript ecosystem that strive to do just this. Flux is a convention for structuring state updates put forward by Facebook. It prescribes that the state can only be updated in a single place and therefore makes it much easier to reason about a given state. Flux is just a design pattern though, popular implementations of Flux include Vuex and Redux. Both of these tools simplify state logic by leverage functional programming ideas. However, they are mainly convention based because javascript as a language is not strict at preventing.</p>\n<p>TODO: transition</p>\n<h1>Functional Programming</h1>\n<p>Functional programming, or FP for short, is a programming paradigm that takes a very different approach from Object Oriented programming. In OO, everything is an object and mutability is widespread while in FP everything is a Function and all values are immutable. These means that FP actively avoids mutable state and therefore reduces incidental complexity. It also prioritizes the use of pure functions. Pure functions are those functions that always return the same output for a given input and do not have any side effects. This gives rise to the idea of referential transparency, which says that a functional call could theoretically be replaced with it’s output and the program would not be affected in any way. This means function programs are highly testable, because nothing outside of the function needs to be considered. The inputs must simply be matched with the expected outputs.</p>\n<p>Most functional languages also have a strong static type system. This means that types are checked at compile time, and a huge amount of run time bugs are eliminated.</p>\n<p>Now if every function in a program were pure, there would be no way to tell that the program ever ran because there would be no sideeffects. So, while FP prioritizes purity, it does allow for side effects. However, these side effects are controlled in that they are encoded directly into the type system. So when a function does affect something outside of itself, you can immediately tell by the function signature.</p>\n<p>In total, these features lead to programs written in a functional way being easy to reason about.</p>\n<h1>Purescript</h1>\n<p>Couldn’t we get most of the benefits of functional programming in modern web applications by using things like Redux, Typescript, and Immutable.js? Yes, it is possible to augment javascript in such a way to reap the benefits of the paradigm. But in my opionion, because javascript was never designed to be a functional language the tools we layer on top of it never solve 100% of the problem and they are not quite as ergonomic as using something with these ideals baked in.</p>\n<p>In my endeavour to apply more functional programming techniques to front end applications I began using purescript. Because purescript compiles to javascript, you can get 100% of the cross platform support with 100% of the benefits of a pure functional language.</p>\n<p>There are of course alternatives to purescript such as ReasonML, Elm, or even compiling Haskell to Javascrip but I have found Purescript to be very easy to work with while still being extremenly powerful.</p>\n<h1>Language Features</h1>\n<p>Purescript has some amazing features that make writing business logic very straightforward.</p>\n<h2>Pattern Matching</h2>\n<p>Here we see a function “f” that has the type Boolean -> String. This means that it accepts a Boolean argument and returns a String. This first line is the type annotation.\nThe two lines below the type annotation are pattern matching cases. When this function is evaluated, purescript will run through these cases top to bottom to find the first pattern which the arguments match. In this case, if “f” is passed true it will return “It’s true”. Otherwise, if “f” is passed false, it will return “It’s not :(“. The compiler also ensures that you have covered all the possible cases, meaning that you will never forget to handle possible variation of the arguments. This is a very declarative way to write a common piece of logic that would look quit different in javascript. In javascript you would presumably write a conditional to check the value of the argument:</p>\n<p>Or perhaps a more terse ES6 version with an arrow function:</p>\n<p>But pattern matching is much more powerful than simple booleans. For example</p>","frontmatter":{"title":"Functional Front-End with Vue and Purescript","date":null}}},"pageContext":{"jsonName":"functional-front-end-704","internalComponentName":"ComponentFunctionalFrontEnd","path":"/functional-front-end/","component":"/Users/sebastian/workspace/sliptype.github.io/src/templates/blog-post.js","componentChunkName":"component---src-templates-blog-post-js","context":{"slug":"/functional-front-end/","previous":{"fields":{"slug":"/styling-in-cyclejs/"},"frontmatter":{"title":"Styling in Cycle.js"}},"next":null},"updatedAt":1554572087206,"pluginCreator___NODE":"Plugin default-site-plugin","pluginCreatorId":"Plugin default-site-plugin","componentPath":"/Users/sebastian/workspace/sliptype.github.io/src/templates/blog-post.js","slug":"/functional-front-end/","previous":{"fields":{"slug":"/styling-in-cyclejs/"},"frontmatter":{"title":"Styling in Cycle.js"}},"next":null}}